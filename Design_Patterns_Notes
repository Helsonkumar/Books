Design Patterns Notes:
=================================
Reference  : 
-------------
https://howtodoinjava.com/design-patterns/structural/composite-design-pattern/#:~:text=pattern%20Final%20notes-,When%20to%20use%20composite%20design%20pattern,generic%20functionality%20across%20the%20structure.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
Things to be explored:
--------------------------
1. Java Recursive Generics(from flunet interface of bulder design pattern)
2. When to use casting and how it works.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



##########################################################################################################################
SOLID Principles:
##########################################################################################################################
SRP : Single Responsibility Principles
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Always create a class with only one responsibility. This makes Ur code or class to be easily managed.
E.q : Consider a Journal Class where we add and remove entries via add and remove method.
Avoid adding additional responsility like Saving and Loading a Journal to/from a file or memory.
This makes the code easy to manage.



Open Closed Principle:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Open for extension and closed for modificcation.

Instead of modifying the existing code for adding new fucntionality, make a Gnereic interface and have that extended 
by the concrete class with new functionality.



Liskov Substituion Principle:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Simply states that we must be able to replace a Sub clas in place where a Base class is expected.
The Behaviour of the method into which the items are substituted must be consistent(mst give appropriate result) with both Base class and Sub class. 



Interface Segregation Principle:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Instead of putting all features in the same interface we need to segerate the features to multiple interface.
Think of  an interface called PrintingDevice whihc has Printing and Scanning feature.
If this is extended by a OldFashionedDevice then it must implement Scannng feature as well whihc is not applicable for that OldFashinedDevice.
That would not make any sense.
So design Ur interface sensibly.



Dependency Inversion Principle:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Simply states that the High level modules must not depend on the low level components.
Code for interface as method parameter instead of the low level discrete type.
Think of Relations and FindRelations example.
Low Level : Which simply exposes a Data structure or storage 
High level : Which utilizes the low level componenet one.



Gamma Categorization
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
1.Creational pattern : Deals with the object creation
2.Structural pattern : Deals with the Class  / Interface design. Insist a good API design
3.Behavioural pattern : Each pattern is unique.


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Creational Pattern :
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------d
****************************************************************************************************************************************************************
Builder Design Pattern:
****************************************************************************************************************************************************************
Motivation :
To construct an object piebce by piece. 
Think of StringBuilder to construct a String with "N" arguments.

Trickiest part:
--------------------
Fluent interface. Calling method on the returned object fluently.

pros:
--------
Use it when an object must be constructed with lot of parameters. We handover the object creation to another object or static class within the same object to be constructed
the task of creating that object.

Recursive Generics:
---------------------
Builder inhert another builder scenario.
When a Object like Person must be constructed by 2 Builders. And Each builder must preseve the fucntionality of one another.
Problem here is to preserve the fluent interface across the inheritence hierarchy.
So we need to use "Recursive Generics".

PersonBuilder< T extends PersonBuilder<T>>.
EmployeeBuilder extends PersonBuilder<EmployeeBuilder>

This way we can preserve the fluent interface across inheritence hierarchy.

FacetedBuilder : 
--------------------
Multiple builder under a common Primary builder.




****************************************************************************************************************************************************************
Factory  Pattern:
****************************************************************************************************************************************************************






****************************************************************************************************************************************************************
Composite  Pattern:
****************************************************************************************************************************************************************
Composite design pattern is a structural pattern which modifies the structure of an object. 
This pattern is most suitable in cases where you need to work with objects which form a tree like hierarchy. 

In that tree, each node/object (except root node) is either composite or leaf node.

Implementing the composite pattern lets clients treat individual objects and compositions uniformly.

E.g : Folder with Folders and Files analogy.

We have a common interface called Componenet
We have Composite(Directory comprises of Files or another Directory) implements Componenet
We have Leaf(File) implements Component

The interface is defined with child management methids (like getFiles, putFiles,etc) also the actual operation

So both Composite and Leaf must implement all methods applicable.

We can ""throw UnsupportedOperationException "" if a method is not applicable.

The Composite simply meaant for Child management....The actual operation is assigned to its child.




****************************************************************************************************************************************************************
Factory  Pattern:
****************************************************************************************************************************************************************

When U want to move the object cration logic to some other seperate code then we will use Factory Design pattern.

Simple Factory :
--------------------
Given a String it will create an instance of a class.
We usually have this in a static method inside a  class.

Simplefactory : Know the list of subclasas for which it will cerate an instance.
Factory : The object creation is delegated to its subclass.
          The list of sublcasses for whihc the instance need to be created is not known in advance.
		  
		  
Factory design Pattern :  Here the ceraetion of objects is delegated to a subclassCreatorFactory.
Each subclass pertains to a subClassCreator.
Adv : The object instance of new class is all about adding new subclass and its relevant subClassCreatorfatory class.
This will make no code change to the interface for any new subclass being added.
DisAdv : But for every new obj creation we need to add new subclass factory.Bu this can be even mitigatd by adding new parameter to the method.

  
  

****************************************************************************************************************************************************************
Abstract factory  Pattern:
****************************************************************************************************************************************************************
Basically used to create a set of related objects .ie. We have 2 object in the same class.
So we have diff creatwor factory for diff combinationof classses.

public tyepA
public typeB

A1 extends A
A2 extends A

B1 extends B
B2 extends B

public abstract class objCreator {

  typeA a;
  type B;

}




public class Comb1Creator extends objCreator{
     //* for A1 and B1
}


public class Comb2Creator extends objCreator{
    // * for A2 and B2
}


****************************************************************************************************************************************************************
Prototype  Pattern:
****************************************************************************************************************************************************************

When we find the 

		  
		  




